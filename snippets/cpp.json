{
	"code starter": {
	"prefix": "letsgo",
	"body": [
		"#include <bits/stdc++.h>",
		"#include <iostream>",
		"using namespace std;",
		"",
		"int main (int argc, char *argv[])",
		"{",
		"  ios_base::sync_with_stdio(false);",
		"  cin.tie(NULL); ",
		"  ${1:$TM_SELECTED_TEXT}",
		"}",
		""
	],
	"description": "code starter"
	},
	"priority queue ascended": {
		"prefix" : "prioascend",
		"body" : "priority_queue<int, vector<int>, greater<int> > pqasc;",
		"description" : "priority queue ascended"
	},
	"Unique BST Elements": {
  "prefix": "bstunique",
  "body": [
    "typedef struct bstnode_t {",
    "    struct bstnode_t *left, *right;",
    "    int key;",
    "} BSTNode;",
    "",
    "/* uniqueBST */",
    "",
    "struct BST {",
    "    // Member",
    "    BSTNode *_root;",
    "    unsigned int _size;",
    "",
    "    // Function",
    "    void init() {",
    "        _root = NULL;",
    "        _size = 0u;",
    "    }",
    "",
    "    bool isEmpty() {",
    "        return _root == NULL;",
    "    }",
    "",
    "    bool find(int value) {",
    "        BSTNode *temp = __search(_root, value);",
    "        if (!temp)",
    "            return false;",
    "        ",
    "        if (temp->key == value)",
    "            return true;",
    "        else",
    "            return false;",
    "    }",
    "",
    "    void insert(int value) {",
    "        if (!find(value)) {",
    "            _root = __insert(_root, value);",
    "            _size++;",
    "        }",
    "    }",
    "",
    "    void remove(int value) {",
    "        if (find(value)) {",
    "            _root = __remove(_root, value);",
    "            _size++;",
    "        }",
    "    }",
    "",
    "    void traverseInorder() {",
    "        __inorder(_root);",
    "    }",
    "",
    "    void traversePreorder() {",
    "        __preorder(_root);",
    "    }",
    "",
    "    void traversePostorder() {",
    "        __postorder(_root);",
    "    }",
    "",
    "private:",
    "    // Utility Function",
    "    BSTNode* __createNode(int value) {",
    "        BSTNode *newNode = (BSTNode*) malloc(sizeof(BSTNode));",
    "        newNode->key = value;",
    "        newNode->left = newNode->right = NULL;",
    "        return newNode;",
    "    }",
    "    ",
    "    BSTNode* __search(BSTNode *root, int value) {",
    "        while (root != NULL) {",
    "            if (value < root->key)",
    "                root = root->left;",
    "            else if (value > root->key)",
    "                root = root->right;",
    "            else",
    "                return root;",
    "        }",
    "        return root;",
    "    }",
    "",
    "    BSTNode* __insert(BSTNode *root, int value) {",
    "        if (root == NULL)",
    "            return __createNode(value);",
    "        ",
    "        if (value < root->key)",
    "            root->left = __insert(root->left, value);",
    "        else if (value > root->key)",
    "            root->right = __insert(root->right, value);",
    "        ",
    "        return root;",
    "    }",
    "",
    "    BSTNode* __findMinNode(BSTNode *node) {",
    "        BSTNode *currNode = node;",
    "        while (currNode && currNode->left != NULL)",
    "            currNode = currNode->left;",
    "        ",
    "        return currNode;",
    "    }",
    "",
    "    BSTNode* __remove(BSTNode *root, int value) {",
    "        if (root == NULL) return NULL;",
    "",
    "        if (value > root->key) ",
    "            root->right = __remove(root->right, value);",
    "        else if (value < root->key) ",
    "            root->left = __remove(root->left, value);",
    "        else {",
    "",
    "            if (root->left == NULL) {",
    "                BSTNode *rightChild = root->right;",
    "                free(root);",
    "                return rightChild;",
    "            }",
    "            else if (root->right == NULL) {",
    "                BSTNode *leftChild = root->left;",
    "                free(root);",
    "                return leftChild;",
    "            }",
    "",
    "            BSTNode *temp = __findMinNode(root->right);",
    "            root->key     = temp->key;",
    "            root->right   = __remove(root->right, temp->key);",
    "        }",
    "        return root;",
    "    }",
    "",
    "    void __inorder(BSTNode *root) {",
    "        if (root) {",
    "            __inorder(root->left);",
    "            printf(\"%d \", root->key);",
    "            __inorder(root->right);",
    "        }",
    "    }",
    "",
    "    void __postorder(BSTNode *root) {",
    "        if (root) {",
    "            __postorder(root->left);",
    "            __postorder(root->right);",
    "            printf(\"%d \", root->key);",
    "        }",
    "    }",
    "",
    "    void __preorder(BSTNode *root) {",
    "        if (root) {",
    "            printf(\"%d \", root->key);",
    "            __preorder(root->left);",
    "            __preorder(root->right);",
    "        }",
    "    }",
    "};",
    ""
  ],
  "description": "Unique BST Elements"
	},
	"AVL Tree": {
  "prefix": "AVL",
  "body": [
    "struct AVLNode {",
    "    int data;",
    "    AVLNode *left, *right;",
    "    int height;",
    "};",
    "",
    "struct AVL",
    "{",
    "private:",
    "    AVLNode *_root;",
    "    unsigned _size;",
    "",
    "    AVLNode* _avl_createNode(int value) {",
    "        AVLNode *newNode = (AVLNode*) malloc(sizeof(AVLNode));",
    "        newNode->data = value;",
    "        newNode->height =1;",
    "        newNode->left = newNode->right = NULL;",
    "        return newNode;",
    "    }",
    "",
    "    AVLNode* _search(AVLNode *root, int value) {",
    "        while (root != NULL) {",
    "            if (value < root->data)",
    "                root = root->left;",
    "            else if (value > root->data)",
    "                root = root->right;",
    "            else",
    "                return root;",
    "        }",
    "        return root;",
    "    }",
    "",
    "    int _getHeight(AVLNode* node){",
    "        if(node==NULL)",
    "            return 0; ",
    "        return node->height;",
    "    }",
    "",
    "    int _max(int a,int b){",
    "        return (a > b)? a : b;",
    "    }",
    "",
    "    AVLNode* _rightRotate(AVLNode* pivotNode){",
    "        AVLNode* newParrent=pivotNode->left;",
    "        pivotNode->left=newParrent->right;",
    "        newParrent->right=pivotNode;",
    "",
    "        pivotNode->height=_max(_getHeight(pivotNode->left),",
    "                        _getHeight(pivotNode->right))+1;",
    "        newParrent->height=_max(_getHeight(newParrent->left),",
    "                        _getHeight(newParrent->right))+1;",
    "        ",
    "        return newParrent;",
    "    }",
    "",
    "    AVLNode* _leftRotate(AVLNode* pivotNode) {",
    "        AVLNode* newParrent=pivotNode->right;",
    "        pivotNode->right=newParrent->left;",
    "        newParrent->left=pivotNode;",
    "",
    "        pivotNode->height=_max(_getHeight(pivotNode->left),",
    "                        _getHeight(pivotNode->right))+1;",
    "        newParrent->height=_max(_getHeight(newParrent->left),",
    "                        _getHeight(newParrent->right))+1;",
    "        ",
    "        return newParrent;",
    "    }",
    "",
    "    AVLNode* _leftCaseRotate(AVLNode* node){",
    "        return _rightRotate(node);",
    "    }",
    "",
    "    AVLNode* _rightCaseRotate(AVLNode* node){",
    "        return _leftRotate(node);",
    "    }",
    "",
    "    AVLNode* _leftRightCaseRotate(AVLNode* node){",
    "        node->left=_leftRotate(node->left);",
    "        return _rightRotate(node);",
    "    }",
    "",
    "    AVLNode* _rightLeftCaseRotate(AVLNode* node){",
    "        node->right=_rightRotate(node->right);",
    "        return _leftRotate(node);",
    "    }",
    "",
    "    int _getBalanceFactor(AVLNode* node){",
    "        if(node==NULL)",
    "            return 0;",
    "        return _getHeight(node->left)-_getHeight(node->right);",
    "    }",
    "",
    "    AVLNode* _insert_AVL(AVLNode* node,int value) {",
    "        ",
    "        if(node==NULL)",
    "            return _avl_createNode(value);",
    "        if(value < node->data)",
    "            node->left = _insert_AVL(node->left,value);",
    "        else if(value > node->data)",
    "            node->right = _insert_AVL(node->right,value);",
    "        ",
    "        node->height= 1 + _max(_getHeight(node->left),_getHeight(node->right)); ",
    "",
    "        int balanceFactor=_getBalanceFactor(node);",
    "        ",
    "        if(balanceFactor > 1 && value < node->left->data)",
    "            return _leftCaseRotate(node);",
    "        if(balanceFactor > 1 && value > node->left->data)",
    "            return _leftRightCaseRotate(node);",
    "        if(balanceFactor < -1 && value > node->right->data)",
    "            return _rightCaseRotate(node);",
    "        if(balanceFactor < -1 && value < node->right->data)",
    "            return _rightLeftCaseRotate(node);",
    "        ",
    "        return node;",
    "    }",
    "",
    "    AVLNode* _findMinNode(AVLNode *node) {",
    "        AVLNode *currNode = node;",
    "        while (currNode && currNode->left != NULL)",
    "            currNode = currNode->left;",
    "        return currNode;",
    "    }",
    "",
    "    AVLNode* _remove_AVL(AVLNode* node,int value){",
    "        if(node==NULL)",
    "            return node;",
    "        if(value > node->data)",
    "            node->right=_remove_AVL(node->right,value);",
    "        else if(value < node->data)",
    "            node->left=_remove_AVL(node->left,value);",
    "        else{",
    "            AVLNode *temp;",
    "            if((node->left==NULL)||(node->right==NULL)){",
    "                temp=NULL;",
    "                if(node->left==NULL) temp=node->right;  ",
    "                else if(node->right==NULL) temp=node->left;",
    "                ",
    "                if(temp==NULL){",
    "                    temp=node;",
    "                    node=NULL;",
    "                }",
    "                else",
    "                    *node=*temp;   ",
    "                ",
    "                free(temp);",
    "            }",
    "            else{",
    "                temp = _findMinNode(node->right);",
    "                node->data=temp->data;",
    "                node->right=_remove_AVL(node->right,temp->data);",
    "            }    ",
    "        }",
    "",
    "        if(node==NULL) return node;",
    "        ",
    "        node->height=_max(_getHeight(node->left),_getHeight(node->right))+1;",
    "",
    "        int balanceFactor= _getBalanceFactor(node);",
    "        ",
    "        if(balanceFactor>1 && _getBalanceFactor(node->left)>=0) ",
    "            return _leftCaseRotate(node);",
    "",
    "        if(balanceFactor>1 && _getBalanceFactor(node->left)<0) ",
    "            return _leftRightCaseRotate(node);",
    "    ",
    "        if(balanceFactor<-1 && _getBalanceFactor(node->right)<=0) ",
    "            return _rightCaseRotate(node);",
    "",
    "        if(balanceFactor<-1 && _getBalanceFactor(node->right)>0) ",
    "            return _rightLeftCaseRotate(node);",
    "        ",
    "        return node;",
    "    }",
    "",
    "    void _inorder(AVLNode *node) {",
    "        if (node) {",
    "            _inorder(node->left);",
    "            printf(\"%d \", node->data);",
    "            _inorder(node->right);",
    "        }",
    "    }",
    "",
    "public:",
    "    void init() {",
    "        _root = NULL;",
    "        _size = 0U;",
    "    }",
    "",
    "    bool isEmpty() {",
    "        return _root == NULL;",
    "    }",
    "",
    "    bool find(int value) {",
    "        AVLNode *temp = _search(_root, value);",
    "        if (temp == NULL)",
    "            return false;",
    "        ",
    "        if (temp->data == value) return true;",
    "        else return false;",
    "    }",
    "",
    "    void insert(int value) {",
    "        if (!find(value)) {",
    "            _root = _insert_AVL(_root, value);",
    "            _size++;",
    "        }",
    "    }",
    "",
    "    void remove(int value) {",
    "        if (find(value)) {",
    "            _root = _remove_AVL(_root, value);",
    "            _size--;",
    "        }",
    "    }",
    "",
    "    void inorder() {",
    "        this->_inorder(_root);",
    "    }",
    "};",
    ""
  ],
  "description": "AVL Tree"
}
}
