{
	"cp": {
		"prefix": "letsgo",
		"body": [
			"#include <stdio.h>",
			"#include <math.h>",
			"#include <string.h>",
			"#include <stdlib.h>",
			"#include <stdbool.h>",
			"",
			"typedef long long int ll;",
			"typedef unsigned long long int ull;",
			"",
			"int main() {",
			"${1:$TM_SELECTED_TEXT}",
			"}",
			""
		],
		"description": "cp"
	},
	"Linked List": {
		"prefix": "llist",
		"body": [
			"#include <stdio.h>",
			"#include <math.h>",
			"#include <string.h>",
			"#include <stdlib.h>",
			"#include <stdbool.h>",
			"",
			"typedef long long int ll;",
			"typedef unsigned long long int ull;",
			"",
			"typedef struct snode_t {",
			"    int data;",
			"    struct snode_t *next;",
			"} node;",
			"",
			"typedef struct slist_t {",
			"    unsigned size;",
			"    node *head;",
			"} list;",
			"",
			"void slist_init(list *list) {",
			"    list->size = 0;",
			"    list->head = NULL;",
			"}",
			"",
			"bool slist_isEmpty(list *list) {",
			"    return (list->head == NULL);",
			"}",
			"",
			"",
			"void slist_pushBack(list *list, int value) {",
			"    node *newNode = (node*) malloc(sizeof(node));",
			"    if (newNode) {",
			"        list->size++;",
			"        newNode->data = value;",
			"        newNode->next = NULL;",
			"        ",
			"        if (slist_isEmpty(list)) list->head = newNode;",
			"        else {",
			"            node *temp = list->head;",
			"            while (temp->next != NULL) ",
			"                temp = temp->next;",
			"            temp->next = newNode;",
			"        }",
			"    }",
			"}",
			"",
			"void slist_pushFront(list *list, int value) {",
			"    node *newNode = (node*) malloc(sizeof(node));",
			"    if (newNode) {",
			"        list->size++;",
			"        newNode->data = value;",
			"        if (slist_isEmpty(list)) newNode->next = NULL;",
			"        else {",
			"            newNode->next = list->head;",
			"        }",
			"        list->head = newNode;",
			"    }",
			"}",
			"",
			"void slist_insertAt(list *list, int index, int value) {",
			"    if (slist_isEmpty(list) || index >= list->size) {",
			"        slist_pushBack(list,value);",
			"        return;",
			"    }",
			"",
			"    else if (index == 0) {",
			"        slist_pushFront(list,value);",
			"        return;",
			"    }",
			"",
			"    node *newNode = (node*) malloc(sizeof(node));",
			"",
			"    if (newNode) {",
			"        node *temp = list->head;",
			"        ",
			"        for (int i=0;i<index-1 && temp->next!=NULL;i++) {",
			"            temp = temp->next;",
			"        }",
			"        newNode->data = value;",
			"        newNode->next = temp->next;",
			"        temp->next = newNode;",
			"        list->size++;  ",
			"    }",
			"}",
			"",
			"int slist_back(list *list) {",
			"    if(!slist_isEmpty(list)) {",
			"        node *temp = list->head;",
			"        while(temp->next == NULL) {",
			"            temp = temp->next;",
			"        }",
			"        return temp->data;",
			"    }",
			"    return 0;",
			"}",
			"",
			"int slist_front(list *list) {",
			"    if (!slist_isEmpty(list)) return list->head->data;",
			"    return 0;",
			"}",
			"",
			"int slist_getAt(list *list, int index) {",
			"    if (!slist_isEmpty(list)) {",
			"        node *temp = list->head;",
			"        for (int i=0;i<index && temp->next != NULL;i++) {",
			"            temp = temp->next;",
			"        }",
			"        return temp->data;",
			"    }",
			"    return 0;",
			"}",
			""
		],
		"description": "Linked List"
	}, 
		"Stack": {
		"prefix": "stack",
		"body": [
			"typedef struct stackNode_t {",
			"    struct stackNode_t *_next;",
			"    int data;",
			"} StackNode; ",
			"",
			"typedef struct stack_t {",
			"    StackNode *_top;",
			"    unsigned length;",
			"} Stack;",
			"",
			"",
			"void stackInit(Stack *stack) {",
			"    stack->length = 0;",
			"    stack->_top = NULL;",
			"}",
			"",
			"bool isEmpty(Stack *stack) {",
			"    if (stack->_top == NULL) {",
			"        return true;",
			"    } else {",
			"        return false;",
			"    }",
			"}",
			"",
			"unsigned stackSize(Stack *stack) {",
			"    return stack->length;",
			"}",
			"",
			"void stackPush(Stack *stack, int input) {",
			"    StackNode *new_node = (StackNode*) malloc(sizeof(StackNode));",
			"    if (new_node) {",
			"        new_node->data = input;",
			"        if (isEmpty(stack)) {",
			"            new_node->_next = NULL;",
			"        } else {",
			"            new_node->_next = stack->_top;",
			"        }",
			"        stack->_top = new_node;",
			"        stack->length++;",
			"    }",
			"}",
			"",
			"void stackPop(Stack *stack) {",
			"    if (isEmpty(stack)) {",
			"        return ;",
			"    } else {",
			"        StackNode *old_top = stack->_top;",
			"        stack->_top = old_top->_next;",
			"        free(old_top);",
			"        stack->length--;",
			"    }",
			"}",
			"",
			"int stackTop(Stack *stack) {",
			"    if (!isEmpty(stack)) return (stack->_top)->data;",
			"    else return 0;",
			"}"
		],
		"description": "Stack"
	}, 
		"Ascending Priority Queue": {
  "prefix": "prioqueueasc",
  "body": [
    "typedef struct pqueueNode_t {",
    "    int data;",
    "    struct pqueueNode_t *next;",
    "} PQueueNode;",
    "",
    "typedef struct pqueue_t {",
    "    unsigned length;",
    "    PQueueNode *_top;",
    "} PQueue;",
    "",
    "bool pqueue_isEmpty(PQueue *pqueue) {",
    "    if (pqueue->_top == NULL) return true;",
    "    else return false;",
    "}",
    "",
    "void pqueueInit(PQueue *pqueue) {",
    "    pqueue->length = 0;",
    "    pqueue->_top =NULL;",
    "}",
    "",
    "// head to tail ascending",
    "void pqueuePush(PQueue *pqueue, int input) {",
    "    PQueueNode *old_top = pqueue->_top;",
    "    PQueueNode *new_node = (PQueueNode*) malloc(sizeof(PQueueNode));",
    "    new_node->data = input;",
    "    new_node->next = NULL;",
    "",
    "    if (pqueue_isEmpty(pqueue)) {",
    "        pqueue->_top = new_node;",
    "    } else if (input < old_top->data) {",
    "        new_node->next = pqueue->_top;",
    "        pqueue->_top = new_node;",
    "    } else {",
    "        while (old_top->next != NULL &&",
    "               old_top->next->data < input) ",
    "            old_top = old_top->next;",
    "        new_node->next = old_top->next;",
    "        old_top->next = new_node;",
    "    }",
    "}",
    "",
    "void pqueuePop(PQueue *pqueue) {",
    "    if (pqueue_isEmpty(pqueue)){",
    "        return;",
    "    }",
    "    PQueueNode *old_top = pqueue->_top;",
    "    pqueue->_top = old_top->next;",
    "    free(old_top);",
    "}",
    "",
    "int pqueueTop(PQueue *pqueue) {",
    "    if (pqueue_isEmpty(pqueue)) return 0;",
    "    return pqueue->_top->data;",
    "}",
    "",
    "int pqueueRear(PQueue *pqueue) {",
    "    if (pqueue_isEmpty(pqueue)) return 0;",
    "    PQueueNode *iter = pqueue->_top;",
    "    while (iter->next != NULL) {",
    "        iter = iter->next;",
    "    }",
    "    return iter->data;",
    "}",
    ""
  ],
  "description": "Ascending Priority Queue"
	},
		"Queue": {
		"prefix": "queue",
		"body": [
			"typedef struct queuenode_t {",
			"    int data;",
			"    struct queuenode_t *next;",
			"} QueueNode;",
			"",
			"typedef struct queue_t {",
			"    unsigned length;",
			"    QueueNode *_top;",
			"    QueueNode *_bottom;",
			"} Queue;",
			"",
			"void queueInit(Queue *queue) {",
			"    queue->length=0;",
			"    queue->_top=NULL;",
			"    queue->_bottom=NULL;",
			"}",
			"",
			"bool isQueueEmpty(Queue *queue) {",
			"    if (queue->_top == NULL && queue->_bottom == NULL) return true;",
			"    else return false;",
			"}",
			"",
			"void queuePush(Queue *queue, int input) {",
			"    QueueNode *new_node = (QueueNode*)malloc(sizeof(QueueNode));",
			"    if(new_node) {",
			"        new_node->data = input;",
			"        new_node->next = NULL;",
			"        queue->length++;",
			"        if (isQueueEmpty(queue)) {",
			"            queue->_bottom = queue->_top = new_node;",
			"        } else {",
			"            (queue->_bottom)->next = new_node;",
			"            queue->_bottom = new_node;",
			"        }",
			"    }",
			"}",
			"",
			"void queuePop(Queue *queue) {",
			"    if(isQueueEmpty(queue)) return ;",
			"    else {",
			"        QueueNode *old_top = queue->_top;",
			"        queue->_top = old_top->next;",
			"        free(old_top);",
			"",
			"        if (queue->_top == NULL) queue->_bottom = NULL;",
			"        queue->length--;",
			"    }",
			"}",
			"",
			"int queueTop(Queue *queue) {",
			"    if(isQueueEmpty(queue)) return 0;",
			"    else return queue->_top->data;",
			"}",
			"",
			"int queueBottom(Queue *queue) {",
			"    if(isQueueEmpty(queue)) return 0;",
			"    else return queue->_bottom->data;",
			"}",
			""
		],
		"description": "Queue"
	},
		"Deque": {
		"prefix": "deque",
		"body": [
			"typedef struct dequenode_t {",
			"    struct dequenode_t *_prev,",
			"                       *_next;",
			"    int data;",
			"} DequeNode;",
			"",
			"typedef struct deque_t {",
			"    DequeNode *_head,",
			"              *_tail;",
			"    unsigned length;    ",
			"} Deque;",
			"",
			"DequeNode* create_dequeNode(int value){",
			"    DequeNode *newNode = (DequeNode*)malloc(sizeof(DequeNode));",
			"    if (!newNode) return NULL;",
			"    newNode->_prev = NULL;",
			"    newNode->_next = NULL;",
			"    newNode->data = value;",
			"",
			"    return (DequeNode*) newNode;",
			"}",
			"",
			"void dequeInit(Deque *deque) {",
			"    deque->_head = NULL;",
			"    deque->_tail = NULL;",
			"    deque->length = 0;",
			"}",
			"",
			"bool isDequeEmpty(Deque *deque) {",
			"    if (deque->length == 0) return true;",
			"    else return false;",
			"}",
			"",
			"void deq_PushFront(Deque *deque, int input) {",
			"    DequeNode* newNode = create_dequeNode(input);",
			"    if (newNode){   ",
			"        deque->length++;",
			"        if(isDequeEmpty(deque)) {",
			"            deque->_head = deque->_tail = newNode;",
			"            return;",
			"        } else {",
			"            newNode->_next = deque->_head;",
			"            deque->_head->_prev = newNode;",
			"            deque->_head = newNode;",
			"        }",
			"    }",
			"}",
			"",
			"void deq_PushBack(Deque *deque, int input) {",
			"    DequeNode* newNode = create_dequeNode(input);",
			"    if (newNode){   ",
			"        deque->length++;",
			"        if(isDequeEmpty(deque)) {",
			"            deque->_head = deque->_tail = newNode;",
			"            return;",
			"        } else {",
			"",
			"            deque->_tail->_next = newNode;",
			"            newNode->_prev = deque->_tail;",
			"            deque->_tail = newNode;",
			"        }",
			"    }",
			"}",
			"",
			"int deq_front(Deque *deque) {",
			"    if (isDequeEmpty(deque)) return 0;",
			"    else return deque->_head->data;",
			"}",
			"",
			"int deq_rear(Deque *deque) {",
			"    if (isDequeEmpty(deque)) return 0;",
			"    else return deque->_tail->data;",
			"}",
			"",
			"void deq_PopFront(Deque *deque) {",
			"    if (isDequeEmpty(deque)) return ;",
			"    else {",
			"        DequeNode* oldHead = deque->_head;",
			"        if (deque->_head == deque->_tail) {",
			"            deque->_head = NULL;",
			"            deque->_tail = NULL;",
			"            free(oldHead);",
			"        } else {",
			"            oldHead->_next->_prev = NULL;",
			"            deque->_head = oldHead->_next;",
			"            free(oldHead);",
			"        }",
			"    }",
			"    deque->length--;",
			"}",
			"",
			"void deq_PopRear(Deque *deque) {",
			"    if (isDequeEmpty(deque)) return ;",
			"    else {",
			"        DequeNode* oldTail = deque->_tail;",
			"        if (deque->_head == deque->_tail) {",
			"            deque->_head = NULL;",
			"            deque->_tail = NULL;",
			"            free(oldTail);",
			"        } else {",
			"            oldTail->_prev->_next = NULL;",
			"            deque->_tail= oldTail->_prev;",
			"            free(oldTail);",
			"        }",
			"    }",
			"    deque->length--;",
			"}"
		],
		"description": "Deque"
	},
			"Descending Priority Queue": {
  "prefix": "prioqueuedesc",
  "body": [
    "typedef struct pqueueNode_t {",
    "    int data;",
    "    struct pqueueNode_t *next;",
    "} PQueueNode;",
    "",
    "typedef struct pqueue_t {",
    "    unsigned length;",
    "    PQueueNode *_top;",
    "} PQueue;",
    "",
    "bool pqueue_isEmpty(PQueue *pqueue) {",
    "    if (pqueue->_top == NULL) return true;",
    "    else return false;",
    "}",
    "",
    "void pqueueInit(PQueue *pqueue) {",
    "    pqueue->length = 0;",
    "    pqueue->_top =NULL;",
    "}",
    "",
    "// head to tail descending",
    "void pqueuePush(PQueue *pqueue, int input) {",
    "    PQueueNode *old_top = pqueue->_top;",
    "    PQueueNode *new_node = (PQueueNode*) malloc(sizeof(PQueueNode));",
    "    new_node->data = input;",
    "    new_node->next = NULL;",
    "",
    "    if (pqueue_isEmpty(pqueue)) {",
    "        pqueue->_top = new_node;",
    "    } else if (input > old_top->data) {",
    "        new_node->next = pqueue->_top;",
    "        pqueue->_top = new_node;",
    "    } else {",
    "        while (old_top->next != NULL &&",
    "               old_top->next->data > input) ",
    "            old_top = old_top->next;",
    "        new_node->next = old_top->next;",
    "        old_top->next = new_node;",
    "    }",
    "}",
    "",
    "void pqueuePop(PQueue *pqueue) {",
    "    if (pqueue_isEmpty(pqueue)){",
    "        return;",
    "    }",
    "    PQueueNode *old_top = pqueue->_top;",
    "    pqueue->_top = old_top->next;",
    "    free(old_top);",
    "}",
    "",
    "int pqueueTop(PQueue *pqueue) {",
    "    if (pqueue_isEmpty(pqueue)) return 0;",
    "    return pqueue->_top->data;",
    "}",
    "",
    "int pqueueRear(PQueue *pqueue) {",
    "    if (pqueue_isEmpty(pqueue)) return 0;",
    "    PQueueNode *iter = pqueue->_top;",
    "    while (iter->next != NULL) {",
    "        iter = iter->next;",
    "    }",
    "    return iter->data;",
    "}",
    ""
  ],
  "description": "Descending Priority Queue"
	}, 
		"Doubly Linked List": {
		"prefix": "doubllist",
		"body": [
			"typedef struct dnode_t {",
			"    int data;",
			"    struct dnode_t      \\",
			"        *next,",
			"        *prev;",
			"} DListNode;",
			"",
			"typedef struct dlist_t {",
			"    DListNode           \\",
			"        *_head, ",
			"        *_tail;",
			"    unsigned _size;",
			"} List;",
			"",
			"DListNode* __dlist_createNode(int value)",
			"{",
			"    DListNode *newNode = \\",
			"        (DListNode*) malloc (sizeof(DListNode));",
			"    ",
			"    if (!newNode) return NULL;",
			"    newNode->data = value;",
			"    newNode->next = NULL;",
			"    newNode->prev = NULL;",
			"",
			"    return (DListNode*) newNode;",
			"}",
			"",
			"void dlist_init(List *list)",
			"{",
			"    list->_head = list->_tail = NULL;",
			"    list->_size = (unsigned) 0;",
			"}",
			"",
			"bool dlist_isEmpty(List *list) {",
			"    return (list->_head == NULL && \\",
			"            list->_tail == NULL);",
			"}",
			"",
			"void dlist_pushFront(List *list, int value)",
			"{",
			"    DListNode *newNode = __dlist_createNode(value);",
			"    if (newNode) {",
			"        list->_size++;",
			"        if (dlist_isEmpty(list)) {",
			"            list->_head = newNode;",
			"            list->_tail = newNode;",
			"            return;",
			"        }",
			"",
			"        newNode->next = list->_head;",
			"        list->_head->prev = newNode;",
			"        list->_head = newNode;",
			"    }",
			"}",
			"",
			"void dlist_pushBack(List *list, int value)",
			"{",
			"    DListNode *newNode = __dlist_createNode(value);",
			"    if (newNode) {",
			"        list->_size++;",
			"        if (dlist_isEmpty(list)) {",
			"            list->_head = newNode;",
			"            list->_tail = newNode;",
			"            return;",
			"        }",
			"",
			"        list->_tail->next = newNode;",
			"        newNode->prev = list->_tail;",
			"        list->_tail = newNode;",
			"    }",
			"}",
			"",
			"void dlist_insertAt(List *list, unsigned index, int value)",
			"{",
			"    if (index == 0) { ",
			"        dlist_pushFront(list, value);",
			"        return;",
			"    }",
			"    else if (index >= list->_size) {",
			"        dlist_pushBack(list, value);",
			"        return;",
			"    }",
			"",
			"    DListNode *newNode = __dlist_createNode(value);",
			"    if (newNode) {",
			"        if (dlist_isEmpty(list)) {",
			"            list->_head = newNode;",
			"            list->_tail = newNode;",
			"            return;",
			"        }",
			"",
			"        DListNode *temp = list->_head;",
			"",
			"        unsigned _i = 0;",
			"        while (_i < index - 1 && temp->next != NULL) {",
			"            temp = temp->next;",
			"            _i++;",
			"        }",
			"        newNode->next = temp->next;",
			"        newNode->prev = temp;",
			"",
			"        if (temp->next)",
			"            temp->next->prev = newNode;",
			"        temp->next = newNode;",
			"        list->_size++;",
			"    }",
			"}",
			"",
			"int dlist_front(List *list) {",
			"    if (!dlist_isEmpty(list)) {",
			"        return (list->_head->data);",
			"    }",
			"    return 0;",
			"}",
			"",
			"int dlist_back(List *list) {",
			"    if (!dlist_isEmpty(list)) {",
			"        return (list->_tail->data);",
			"    }",
			"    return 0;",
			"}",
			"",
			"void dlist_popFront(List *list)",
			"{",
			"    if (!dlist_isEmpty(list)) {",
			"        DListNode *temp = list->_head;",
			"        if (list->_head == list->_tail) {",
			"            list->_head = NULL;",
			"            list->_tail = NULL;",
			"            free(temp);",
			"        }",
			"        else {",
			"            list->_head = list->_head->next;",
			"            list->_head->prev = NULL;",
			"            free(temp);",
			"        }",
			"        list->_size--;",
			"    }",
			"}",
			"",
			"void dlist_popBack(List *list)",
			"{",
			"    if (!dlist_isEmpty(list)) {",
			"        DListNode *temp;",
			"        if (list->_head == list->_tail) {",
			"            temp = list->_head;",
			"            list->_head = NULL;",
			"            list->_tail = NULL;",
			"            free(temp);",
			"        }",
			"        else {",
			"            temp = list->_tail;",
			"            list->_tail = list->_tail->prev;",
			"            list->_tail->next = NULL;",
			"            free(temp);",
			"        }",
			"        list->_size--;",
			"    }",
			"}"
		],
		"description": "Doubly Linked List"
	}
}

